# Import numpy
import numpy as np
from numba import njit

class grid2D:
    
    def __init__( self, origin, step, npoints ):
        self.origin_ = origin
        self.step_ = step #assumes a scalar and constant step size
        self.nu_ = npoints[0]
        self.nv_ = npoints[1]
    
    def point(self, u, v):
        return [self.origin_[0]+u*self.step_, self.origin_[1]+v*self.step_]

@njit
def index(array, item):
    "This is the most faster and performant method to seek the index quickly in a multidimensional array"
    "@njit is a library that I found in Stack Overflow that reduce the time consuming "
    for idx, val in np.ndenumerate(array):
        if val == item:
            return idx
    # If no item was found return None, other return types might be a problem due to
    # numbas type inference.
    
def projection(evalpts, step ): 
    "The evalpts must be an array of 3 colums corresponding to the x,y,z coordinates of the NURBS points"
    "and as many rows as points sampling the NURBS surface. They are the points generated by NURBS library"
    "Step is the spacing among 2D grid nodes"
    "TODO: use the origin/ end parameters"  
    
    # Split the evalpts into 3 array
    # Each of those array have only 1 coordinate: x,y,z
    xs = evalpts[:,0]
    ys = evalpts[:,1]
    zs = evalpts[:,2]

    # Define the boundary of the grid
    # And define the step size of the 2D
    xmin,xmax = xs.min(), xs.max()
    xstep = xs[xs!=xmin].min()-xmin
    ymin,ymax = ys.min(), ys.max()
    ystep = ys[ys!=ymin].min()-ymin

    # Built a regular grid with spacing of step size for x,y
    # The chose of those parameters it depends on data set
    grid_x,grid_y = np.mgrid[356617-(step):358570+(step):(step),4795822-(step):4799560+(step):(step)]

    # The 2D array of Z proprieties 
    grid_z = np.ones(grid_x.shape)*zs.max()
    
    # Define blank array for the loop 
    sq_min_distances = np.ones(grid_x.shape)*(np.square(xmax-xmin) + np.square(ymax-ymin))
        
    # Algorithm to project vertically the 2D grid on parametric surface, 
    # even though we technically do the opposite
    for i in range(len(xs)):    
        cur_nurbs_point = [xs[i],ys[i]]
        sq_distance = np.square(grid_x-cur_nurbs_point[0]) + np.square(grid_y-cur_nurbs_point[1])
        index_position_closest = index(sq_distance,sq_distance.min())
        sq_distance_2grid = sq_distance.min()
        closest_grid_index = index_position_closest[0], index_position_closest[1]
        if sq_distance_2grid < sq_min_distances[closest_grid_index]:
            sq_min_distances[closest_grid_index] = sq_distance_2grid
            grid_z[closest_grid_index]= zs[i]
    
    return grid_z


# Erosion function among the surfaces
def erode( grid ):
    for ihroz in range(0,len(grid)-1):
        for iu in range(grid[ihroz].shape[0]):
            for iv in range(grid[ihroz].shape[1]):
                if grid[ihroz][iu][iv] < grid[ihroz+1][iu][iv]:
                    grid[ihroz+1][iu][iv] = grid[ihroz][iu][iv]
    return grid